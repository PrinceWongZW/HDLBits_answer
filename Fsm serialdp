module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //
    parameter idle = 13'h0001, rdy = 13'h0002, b8 = 13'h0400, fnsh = 13'h0800, pre = 13'h1000;
    reg [12:0] state, nstate;
    reg [7:0] out_buff;
    reg rst;
    wire odck;
    
    // New: Add parity checking.
    assign rst = reset || (nstate==rdy);
    parity pcheck(clk, rst, in, odck);

    // Modify FSM and datapath from Fsm_serialdata
    // Use FSM from Fsm_serial
    always @ (*) begin
        case(state)
            idle : nstate = ~in ? rdy : idle;
            b8 : nstate = in ? fnsh : pre;
            fnsh : nstate = ~in ? rdy : idle;
            pre : nstate = in ? idle : pre;
            default : nstate = state << 1;
        endcase
    end

    always @ (posedge clk) begin
        if(reset) begin
            state <= idle;
            done <= 0;
        end
        else begin
            state <= nstate;
            if(nstate==fnsh && odck)
                done <= 1;
            else
                done <= 0;
        end
    end
    
    // New: Datapath to latch input bits.
    always @ (posedge clk) begin
        if(nstate==13'h0004 || nstate==13'h0008 || nstate==13'h0010 || nstate==13'h0020 || nstate==13'h0040 || nstate==13'h0080 || nstate==13'h0100 || nstate==13'h0200)
            out_buff <= (out_buff<<1) | in;
    end
    
    assign out_byte[0] = out_buff[7];
    assign out_byte[1] = out_buff[6];
    assign out_byte[2] = out_buff[5];
    assign out_byte[3] = out_buff[4];
    assign out_byte[4] = out_buff[3];
    assign out_byte[5] = out_buff[2];
    assign out_byte[6] = out_buff[1];
    assign out_byte[7] = out_buff[0];

endmodule

